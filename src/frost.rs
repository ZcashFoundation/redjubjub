//! An implementation of FROST (Flexible Round-Optimized Schnorr Threshold)
//! signatures.
//!
//! > **WARNING**: This implementation is unstable and subject to
//! > revision. It is not covered by the crate's semver guarantees and should not
//! > be deployed without consultation from the FROST authors!
//!
//! This implementation currently only supports key generation using a central
//! dealer. In the future, we will add support for key generation via a DKG,
//! as specified in the FROST paper.
//! Internally, keygen_with_dealer generates keys using Verifiable Secret
//! Sharing,  where shares are generated using Shamir Secret Sharing.

// TODO: all public structs/data that includes points must use/wrap
use rand_core::{CryptoRng, RngCore};
use std::convert::TryFrom;

use std::{collections::HashMap, marker::PhantomData};

use crate::private::Sealed;
use crate::{HStar, Scalar, Signature, SpendAuth, VerificationKey};

#[derive(Copy, Clone)]
/// Secret is comprised of secret scalar.
pub struct Secret(Scalar);

// TODO: impl From<Scalar> for Secret;

#[derive(Copy, Clone)]
/// Public is comprised of a public group element and represents a single
/// signer's public key
pub struct Public(jubjub::ExtendedPoint);

// TODO: impl From<jubjub::ExtendedPoint> for Public;

/// A share generated by Shamir's secret sharing.
#[derive(Clone)]
pub struct Share {
    pub(crate) receiver_index: u32,
    pub(crate) value: Secret,
    pub(crate) commitment: ShareCommitment,
}

/// Commitment is a Jubjub point that is a commitment to one coefficient of a
/// secret polynomial.
#[derive(Clone)]
struct Commitment(jubjub::ExtendedPoint);

/// ShareCommitment contains the commitments to the coefficients (which
/// themselves are scalars) for a secret polynomial f, used to generate each
/// participants key shares.
#[derive(Clone)]
pub struct ShareCommitment(Vec<Commitment>);

/// GroupCommitment is the product of all signer's individual commitments and
/// what is published as part of the final signature.
pub struct GroupCommitment(jubjub::ExtendedPoint);

/// SharePackage is secret and public key material generated by a dealer
/// performing keygen_with_dealer. To derive a FROST keypair, the receiver of
/// the SharePackage *must* call .into(), which under the hood also performs
/// validation.
pub struct SharePackage {
    /// index denotes the participant index each share is owned by
    pub index: u32,
    pub(crate) share: Share,
    pub(crate) public: Public,
    pub(crate) group_public: VerificationKey<SpendAuth>,
}

impl TryFrom<SharePackage> for KeyPackage {
    type Error = &'static str;

    fn try_from(sharepackage: SharePackage) -> Result<Self, &'static str> {
        // first, ensure that the share itself is valid
        verify_share(&sharepackage.share)?;

        Ok(KeyPackage {
            index: sharepackage.index,
            secret_share: sharepackage.share.value,
            public: sharepackage.public,
            group_public: sharepackage.group_public,
        })
    }
}

/// KeyPackage is a FROST keypair. This keypair can be generated either by a
/// trusted dealer or using a DKG.
pub struct KeyPackage {
    pub(crate) index: u32,
    pub(crate) secret_share: Secret,
    pub(crate) public: Public,
    pub(crate) group_public: VerificationKey<SpendAuth>,
}

/// Public data that contains all the singer's public keys as well as the
/// group public key. Used for verification purposes before publishing a
/// signature.
pub struct PublicKeyPackage {
    pub(crate) signer_pubkeys: HashMap<u32, Public>,
    /// group_public represents the joint public key for the entire group.
    pub group_public: VerificationKey<SpendAuth>,
}

/// keygen with dealer allows all participants' keys to be generated using a
/// central, trusted dealer. This action is essentially Verifiable Secret
/// Sharing, which itself uses Shamir secret sharing, from which each share
/// becomes a participant's secret key.
/// The output from this function is a set of shares along with one single
/// commitment.
pub fn keygen_with_dealer<R: RngCore + CryptoRng>(
    num_signers: u32,
    threshold: u32,
    mut rng: R,
) -> Result<(Vec<SharePackage>, PublicKeyPackage), &'static str> {
    let mut bytes = [0; 64];
    rng.fill_bytes(&mut bytes);

    let secret = Secret(Scalar::from_bytes_wide(&bytes));
    let group_pk_bytes = jubjub::AffinePoint::from(SpendAuth::basepoint() * secret.0).to_bytes();
    let group_public = match VerificationKey::try_from(group_pk_bytes) {
        Ok(x) => x,
        Err(_) => return Err("Cannot convert public key"),
    };

    let shares = generate_shares(secret, num_signers, threshold, rng)?;
    let mut sharepackages: Vec<SharePackage> = Vec::with_capacity(num_signers as usize);
    let mut signer_pubkeys: HashMap<u32, Public> = HashMap::with_capacity(num_signers as usize);

    for share in shares {
        let signer_public = Public(SpendAuth::basepoint() * share.value.0);
        sharepackages.push(SharePackage {
            index: share.receiver_index,
            share: share.clone(),
            public: signer_public,
            group_public: group_public,
        });

        signer_pubkeys.insert(share.receiver_index, signer_public);
    }

    Ok((
        sharepackages,
        PublicKeyPackage {
            signer_pubkeys,
            group_public,
        },
    ))
}

/// verify_shares verifies that a share is consistent with a commitment,
/// ensuring that this participant's share is consistent with all other signing
/// participants. Note that participants *must* ensure that they have the same
/// view as all other participants of the commitment!
fn verify_share(share: &Share) -> Result<(), &'static str> {
    let f_result = SpendAuth::basepoint() * share.value.0;

    let x = Scalar::from(share.receiver_index as u64);

    let (_, result) = share.commitment.0.iter().fold(
        (Scalar::one(), jubjub::ExtendedPoint::identity()),
        |(x_to_the_i, sum_so_far), comm_i| (x_to_the_i * x, sum_so_far + comm_i.0 * x_to_the_i),
    );

    if !(f_result == result) {
        return Err("Share is invalid.");
    }

    Ok(())
}

/// generate_shares creates secret shares for a given secret. This function
/// accepts a secret to generate shares from. While in FROST this secret should
/// always be generated randomly, we allow this secret to be specified for this
/// internal function for testability
///
/// Internally, generate_shares performs Verifiable Secret Sharing, which
/// generates shares via Shamir Secret Sharing, and then generates public
/// commitments to those shares.
/// More specifically, generate_shares performs:
/// - Randomly sampling of coefficents [a, b, c], this represents a secret
/// polynomial f
/// - For each participant i, their secret share is f(i)
/// - The commitment to the secret polynomial f is [g^a, g^b, g^c]
fn generate_shares<R: RngCore + CryptoRng>(
    secret: Secret,
    numshares: u32,
    threshold: u32,
    mut rng: R,
) -> Result<Vec<Share>, &'static str> {
    if threshold < 1 {
        return Err("Threshold cannot be 0");
    }
    if numshares < 1 {
        return Err("Number of shares cannot be 0");
    }
    if threshold > numshares {
        return Err("Threshold cannot exceed numshares");
    }

    let numcoeffs = threshold - 1;

    let mut coefficients: Vec<Scalar> = Vec::with_capacity(threshold as usize);

    let mut shares: Vec<Share> = Vec::with_capacity(numshares as usize);

    let mut commitment: ShareCommitment = ShareCommitment(Vec::with_capacity(threshold as usize));

    for _ in 0..numcoeffs {
        let mut bytes = [0; 64];
        rng.fill_bytes(&mut bytes);
        coefficients.push(Scalar::from_bytes_wide(&bytes));
    }

    commitment
        .0
        .push(Commitment(SpendAuth::basepoint() * secret.0));

    for c in &coefficients {
        commitment.0.push(Commitment(SpendAuth::basepoint() * c));
    }

    for index in 1..numshares + 1 {
        // Evaluate the polynomial with `secret` as the constant term
        // and `coeffs` as the other coefficients at the point x=share_index
        // using Horner's method
        let scalar_index = Scalar::from(index as u64);
        let mut value = Scalar::zero();
        for i in (0..numcoeffs).rev() {
            value += &coefficients[i as usize];
            value *= scalar_index;
        }
        value += secret.0;
        shares.push(Share {
            receiver_index: index,
            value: Secret(value),
            commitment: commitment.clone(),
        });
    }

    Ok(shares)
}

/// All the nonces needed to generate a randomized signing key
/// and the rest of the signature. You don't want to use them
/// more than once.
#[derive(Clone)]
pub struct SigningNonces {
    randomizer: crate::Randomizer,
    hiding: Scalar,
    binding: Scalar,
}

impl Drop for SigningNonces {
    fn drop(&mut self) {}
}

impl SigningNonces {
    /// generates a new signing nonce
    pub fn new<R>(rng: &mut R) -> Self
    where
        R: CryptoRng + RngCore,
    {
        let mut bytes = [0; 64];
        rng.fill_bytes(&mut bytes);
        let randomizer = Scalar::from_bytes_wide(&bytes);

        let mut bytes = [0; 64];
        rng.fill_bytes(&mut bytes);
        let hiding = Scalar::from_bytes_wide(&bytes);

        let mut bytes = [0; 64];
        rng.fill_bytes(&mut bytes);
        let binding = Scalar::from_bytes_wide(&bytes);

        Self {
            randomizer,
            hiding,
            binding,
        }
    }
}

#[derive(Copy, Clone)]
/// SigningCommitments are published before performing signing.
pub struct SigningCommitments {
    /// MUST match the receiver_index used during keygen
    index: u32,
    randomizer: jubjub::ExtendedPoint,
    hiding: jubjub::ExtendedPoint,
    binding: jubjub::ExtendedPoint,
}

impl From<(u32, &SigningNonces)> for SigningCommitments {
    /// For SpendAuth signatures only, not Binding signatures, in RedJubjub/Zcash.
    fn from((index, nonces): (u32, &SigningNonces)) -> Self {
        Self {
            index,
            randomizer: SpendAuth::basepoint() * nonces.randomizer,
            hiding: SpendAuth::basepoint() * nonces.hiding,
            binding: SpendAuth::basepoint() * nonces.binding,
        }
    }
}

/// The group of stuff distributed by the signing coordinator
/// and distributed to each signing party.
pub struct SigningPackage {
    /// message which each participant will sign
    pub message: &'static [u8],
    /// signing_commitments are the set of commitments participants published in the first round.
    pub signing_commitments: Vec<SigningCommitments>,
}

/// A participant's signature share, which later will be aggregated into the
/// complete signature.
pub struct SignatureShare {
    pub(crate) index: u32,
    pub(crate) signature: Scalar,
}
impl SignatureShare {
    /// is_valid tests if a signature share issued by a participant is valid
    /// before aggregating it into a final joint signature to publish
    pub fn check_is_valid(
        &self,
        pubkey: &Public,
        lambda_i: Scalar,
        commitment: jubjub::ExtendedPoint,
        challenge: Scalar,
    ) -> Result<(), &'static str> {
        if (SpendAuth::basepoint() * &self.signature)
            != (commitment + pubkey.0 * challenge * lambda_i)
        {
            return Err("Invalid signature share");
        }
        Ok(())
    }
}

/// Done once by each participant, to generate _their_ values to contribute to signing.
/// Depending on how many participants are contributing to the group signature, that determines
/// n sets of nonces and corresponding commitments. All packages are identified by your index.
///
/// Non-interactive; receives number of nonces and commitments
/// you want to derive, outputs a set of commitments and set of nonces:
/// the commitments are public, the nonces should stored in secret storage for later use.
pub fn preprocess<R>(
    n: u32,
    my_index: u32,
    rng: &mut R,
) -> (Vec<SigningNonces>, Vec<SigningCommitments>)
where
    R: CryptoRng + RngCore,
{
    let mut signing_nonces: Vec<SigningNonces> = Vec::with_capacity(n as usize);
    let mut signing_commitments: Vec<SigningCommitments> = Vec::with_capacity(n as usize);

    for _ in 0..n {
        let nonces = SigningNonces::new(rng);
        signing_commitments.push(SigningCommitments::from((my_index, &nonces)));
        signing_nonces.push(nonces);
    }

    (signing_nonces, signing_commitments)
}

fn gen_rho_i(index: u32, signing_package: &SigningPackage) -> Scalar {
    let mut hasher = HStar::default();
    hasher
        .update("RHO_CONTEXT_STRING".as_bytes()) // TODO decide on context string
        .update(index.to_be_bytes())
        .update(signing_package.message);

    for item in signing_package.signing_commitments.iter() {
        hasher.update(item.index.to_be_bytes());
        let hiding_bytes = jubjub::AffinePoint::from(item.hiding).to_bytes();
        hasher.update(hiding_bytes);
        let binding_bytes = jubjub::AffinePoint::from(item.binding).to_bytes();
        hasher.update(binding_bytes);
    }

    hasher.finalize()
}

fn gen_group_commitment(
    signing_package: &SigningPackage,
    bindings: &HashMap<u32, Scalar>,
) -> Result<GroupCommitment, &'static str> {
    let mut accumulator = jubjub::ExtendedPoint::identity();

    for commitment in signing_package.signing_commitments.iter() {
        let rho_i = bindings[&commitment.index];
        accumulator += commitment.hiding + (commitment.binding * rho_i)
    }

    Ok(GroupCommitment(accumulator))
}

fn gen_challenge(
    signing_package: &SigningPackage,
    group_commitment: &GroupCommitment,
    group_public: &VerificationKey<SpendAuth>,
) -> Scalar {
    let group_commitment_bytes = jubjub::AffinePoint::from(group_commitment.0).to_bytes();

    HStar::default()
        .update(group_commitment_bytes)
        .update(group_public.bytes.bytes)
        .update(signing_package.message)
        .finalize()
}

/// generates the langrange coefficient for the ith participant.
fn gen_lagrange_coeff(
    signer_index: u32,
    signing_package: &SigningPackage,
) -> Result<Scalar, &'static str> {
    let mut num = Scalar::one();
    let mut den = Scalar::one();
    for commitment in signing_package.signing_commitments.iter() {
        if commitment.index == signer_index {
            continue;
        }
        num *= Scalar::from(commitment.index as u64);
        den *= Scalar::from(commitment.index as u64) - Scalar::from(signer_index as u64);
    }

    if den == Scalar::zero() {
        return Err("Duplicate shares provided");
    }

    // TODO handle this unwrap
    let lagrange_coeff = num * den.invert().unwrap();

    Ok(lagrange_coeff)
}

/// Performed once by each participant selected for the signing operation.
/// Receives the message to be signed and a set of signing commitments and
/// a set of randomizing commitments to be used in that signing operation,
/// including your own.
/// Assumes you've already found the nonce that corresponds with the commitment
/// that you are using for yourself.
pub fn sign(
    signing_package: &SigningPackage,
    my_nonces: &SigningNonces, // TODO this should probably consume the nonce
    share_package: &SharePackage,
) -> Result<SignatureShare, &'static str> {
    let mut bindings: HashMap<u32, Scalar> =
        HashMap::with_capacity(signing_package.signing_commitments.len());

    for comm in signing_package.signing_commitments.iter() {
        let rho_i = gen_rho_i(comm.index, &signing_package);
        bindings.insert(comm.index, rho_i);
    }

    let lambda_i = gen_lagrange_coeff(share_package.index, &signing_package)?;

    let group_commitment = gen_group_commitment(&signing_package, &bindings)?;

    let c = gen_challenge(
        &signing_package,
        &group_commitment,
        &share_package.group_public,
    );

    let my_rho_i = bindings[&share_package.index];

    let signature: Scalar = my_nonces.hiding
        + (my_nonces.binding * my_rho_i)
        + (lambda_i * share_package.share.value.0 * c);

    Ok(SignatureShare {
        index: share_package.index,
        signature,
    })
}

/// Verifies each participant's signature share, and if all are valid,
/// aggregates the shares into a signature to publish
pub fn aggregate(
    signing_package: &SigningPackage,
    signing_shares: &Vec<SignatureShare>,
    pubkeys: &PublicKeyPackage,
) -> Result<Signature<SpendAuth>, &'static str> {
    let mut bindings: HashMap<u32, Scalar> =
        HashMap::with_capacity(signing_package.signing_commitments.len());

    for comm in signing_package.signing_commitments.iter() {
        let rho_i = gen_rho_i(comm.index, &signing_package);
        bindings.insert(comm.index, rho_i);
    }

    let group_commitment = gen_group_commitment(&signing_package, &bindings)?;

    let challenge = gen_challenge(&signing_package, &group_commitment, &pubkeys.group_public);

    for signing_share in signing_shares {
        let signer_pubkey = pubkeys.signer_pubkeys[&signing_share.index];
        let lambda_i = gen_lagrange_coeff(signing_share.index, &signing_package)?;
        let signer_commitment = signing_package
            .signing_commitments
            .iter()
            .find(|comm| comm.index == signing_share.index)
            .ok_or("No matching signing commitment for signer")?;

        let commitment_i =
            signer_commitment.hiding + (signer_commitment.binding * bindings[&signing_share.index]);

        signing_share.check_is_valid(&signer_pubkey, lambda_i, commitment_i, challenge)?;
    }

    let mut z = Scalar::zero();
    for signature_share in signing_shares {
        z += signature_share.signature;
    }

    let r_bytes = jubjub::AffinePoint::from(group_commitment.0).to_bytes();

    Ok(Signature {
        r_bytes,
        s_bytes: z.to_bytes(),
        _marker: PhantomData,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::thread_rng;

    fn reconstruct_secret(shares: Vec<Share>) -> Result<Scalar, &'static str> {
        let numshares = shares.len();

        if numshares < 1 {
            return Err("No shares provided");
        }

        let mut lagrange_coeffs: Vec<Scalar> = Vec::with_capacity(numshares as usize);

        for i in 0..numshares {
            let mut num = Scalar::one();
            let mut den = Scalar::one();
            for j in 0..numshares {
                if j == i {
                    continue;
                }
                num *= Scalar::from(shares[j].receiver_index as u64);
                den *= Scalar::from(shares[j].receiver_index as u64)
                    - Scalar::from(shares[i].receiver_index as u64);
            }
            if den == Scalar::zero() {
                return Err("Duplicate shares provided");
            }
            lagrange_coeffs.push(num * den.invert().unwrap());
        }

        let mut secret = Scalar::zero();

        for i in 0..numshares {
            secret += lagrange_coeffs[i] * shares[i].value.0;
        }

        Ok(secret)
    }

    /// This is testing that Shamir's secret sharing to compute and arbitrary
    /// value is working.
    #[test]
    fn check_share_generation() {
        let mut rng = thread_rng();

        let mut bytes = [0; 64];
        rng.fill_bytes(&mut bytes);
        let secret = Secret(Scalar::from_bytes_wide(&bytes));

        let _ = SpendAuth::basepoint() * secret.0;

        let shares = generate_shares(secret, 5, 3, rng).unwrap();

        for share in shares.iter() {
            assert_eq!(verify_share(&share), Ok(()));
        }

        assert_eq!(reconstruct_secret(shares).unwrap(), secret.0)
    }
}
