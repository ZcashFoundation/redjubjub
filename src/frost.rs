//! An implementation of FROST (Flexible Round-Optimized Schnorr Threshold)
//! signatures.
//!
//! > **WARNING**: The implementation in this submodule is unstable and subject to
//! > revision. It is not covered by the crate's semver guarantees and should not
//! > be deployed without consultation from the FROST authors!

/// keygen with dealer
/// - randomly sample coefficents [a, b, c], this represents polynomial f
/// - for each participant i, their secret share is f(i)
/// - the commitment to f is [g^a, g^b, g^c]
///
/// validate(f(i), commitment)
/// ... some math
///
/// DKG:
/// Round 1: - each participant performs 'keygen with dealer' as the dealer to everyone else (N-to-N),
/// sends (commitment, signature) proving they know coefficent 0 to all other participants
/// Round 2: send shares to all other participants
/// aggregate shares i received to get my secret and public
///
/// group public key: prod g^coefficient 0
/// share
// TODO: all public structs/data that includes points must use/wrap
// jubjub::AffinePoint, because that serialization is the canonical one,
// vs ExtendedPoint, etc
use rand_core::{CryptoRng, RngCore};

use crate::private::Sealed;
use crate::{Scalar, SpendAuth};

#[derive(Copy, Clone)]
/// Secret is comprised of secret scalar.
pub struct Secret(Scalar);

// TODO: impl From<Scalar> for Secret;

#[derive(Copy, Clone)]
/// Public is comprised of a public group element
pub struct Public(jubjub::ExtendedPoint);

// TODO: impl From<jubjub::ExtendedPoint> for Public;

#[derive(Copy, Clone)]
/// GroupPublic represents the signing group's public key.
pub struct GroupPublic(jubjub::ExtendedPoint);

// TODO: impl From<jubjub::ExtendedPoint> for GroupPublic;

/// A share generated by Shamir's secret sharing.
#[derive(Clone)]
struct Share {
    pub(crate) receiver_index: u32,
    pub(crate) value: Secret,
}

/// A Jubjub point that is a commitment to one coefficient of the polynomial.
struct Commitment(jubjub::ExtendedPoint);

/// A commitment to verify the correctness of any `Share` that came out of common keygen.
///
/// A single value that is used to verify that any of a bunch of `Share`s that resulted
/// from a keygen round is consistent with that commitment.
///
/// Commits to the coefficients (which are scalars) of the Shamir secret sharing polynomial.
pub struct KeygenCommitment(Vec<Commitment>);

/// Create secret shares for a given secret. This function accepts a secret to
/// generate shares from. While in FROST this secret should always be generated
/// randomly, we allow this secret to be specified for this internal function
/// for testability
fn generate_shares<R: RngCore + CryptoRng>(
    secret: Secret,
    numshares: u32,
    threshold: u32,
    mut rng: R,
) -> Result<(KeygenCommitment, Vec<Share>), &'static str> {
    if threshold < 1 {
        return Err("Threshold cannot be 0");
    }
    if numshares < 1 {
        return Err("Number of shares cannot be 0");
    }
    if threshold > numshares {
        return Err("Threshold cannot exceed numshares");
    }

    let numcoeffs = threshold - 1;

    let mut coefficients: Vec<Scalar> = Vec::with_capacity(threshold as usize);

    let mut shares: Vec<Share> = Vec::with_capacity(numshares as usize);

    let mut keygen_commitment: KeygenCommitment =
        KeygenCommitment(Vec::with_capacity(threshold as usize));

    for _ in 0..numcoeffs {
        let mut bytes = [0; 64];
        rng.fill_bytes(&mut bytes);
        coefficients.push(Scalar::from_bytes_wide(&bytes));
    }

    keygen_commitment
        .0
        .push(Commitment(SpendAuth::basepoint() * secret.0));

    for c in &coefficients {
        keygen_commitment
            .0
            .push(Commitment(SpendAuth::basepoint() * c));
    }

    for index in 1..numshares + 1 {
        // Evaluate the polynomial with `secret` as the constant term
        // and `coeffs` as the other coefficients at the point x=share_index
        // using Horner's method
        let scalar_index = Scalar::from(index as u64);
        let mut value = Scalar::zero();
        for i in (0..numcoeffs).rev() {
            value += &coefficients[i as usize];
            value *= scalar_index;
        }
        value = value + secret.0;
        shares.push(Share {
            receiver_index: index,
            value: Secret(value),
        });
    }

    Ok((keygen_commitment, shares))
}

/// A general FROST keypair that results from distributed key generation (or
/// from keygen by a central dealer).
pub struct KeyPackage {
    pub(crate) index: u32,
    pub(crate) secret_share: Secret,
    pub(crate) public: Public,
    pub(crate) group_public: GroupPublic,
}

/// keygen with dealer
/// - randomly sample coefficents [a, b, c], this represents polynomial f
/// - for each participant i, their secret share is f(i)
/// - the commitment to f is [g^a, g^b, g^c]
pub fn keygen_with_dealer<R: RngCore + CryptoRng>(
    num_signers: u32,
    threshold: u32,
    mut rng: R,
) -> Result<(KeygenCommitment, Vec<KeyPackage>), &'static str> {
    let mut bytes = [0; 64];
    rng.fill_bytes(&mut bytes);

    let secret = Secret(Scalar::from_bytes_wide(&bytes));
    let group_public = SpendAuth::basepoint() * secret.0;

    let (keygen_commitment, shares) = generate_shares(secret, num_signers, threshold, rng)?;
    let keypairs = shares
        .iter()
        .map(|share| KeyPackage {
            index: share.receiver_index,
            secret_share: share.value,
            public: Public(SpendAuth::basepoint() * share.value.0),
            group_public: GroupPublic(group_public),
        })
        .collect();

    Ok((keygen_commitment, keypairs))
}

/// Verify that a share is consistent with a commitment.
fn verify_share(share: &Share, com: &KeygenCommitment) -> Result<(), &'static str> {
    let f_result = SpendAuth::basepoint() * share.value.0;

    let x = Scalar::from(share.receiver_index as u64);

    let (_, result) = com.0.iter().fold(
        (Scalar::one(), jubjub::ExtendedPoint::identity()),
        |(x_to_the_i, sum_so_far), comm_i| (x_to_the_i * x, sum_so_far + comm_i.0 * x_to_the_i),
    );

    if !(f_result == result) {
        return Err("Share is invalid.");
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::{self, rngs::ThreadRng};

    fn reconstruct_secret(shares: Vec<Share>) -> Result<Scalar, &'static str> {
        let numshares = shares.len();

        if numshares < 1 {
            return Err("No shares provided");
        }

        let mut lagrange_coeffs: Vec<Scalar> = Vec::with_capacity(numshares as usize);

        for i in 0..numshares {
            let mut num = Scalar::one();
            let mut den = Scalar::one();
            for j in 0..numshares {
                if j == i {
                    continue;
                }
                num *= Scalar::from(shares[j].receiver_index as u64);
                den *= Scalar::from(shares[j].receiver_index as u64)
                    - Scalar::from(shares[i].receiver_index as u64);
            }
            if den == Scalar::zero() {
                return Err("Duplicate shares provided");
            }
            lagrange_coeffs.push(num * den.invert().unwrap());
        }

        let mut secret = Scalar::zero();

        for i in 0..numshares {
            secret += lagrange_coeffs[i] * shares[i].value.0;
        }

        Ok(secret)
    }

    /// This is testing that Shamir's secret sharing to compute and arbitrary
    /// value is working.
    #[test]
    fn check_share_generation() {
        let mut rng: ThreadRng = rand::thread_rng();

        let mut bytes = [0; 64];
        rng.fill_bytes(&mut bytes);
        let secret = Secret(Scalar::from_bytes_wide(&bytes));

        let _ = SpendAuth::basepoint() * secret.0;

        let (keygen_commitment, shares) = generate_shares(secret, 5, 3, rng).unwrap();

        for share in shares.iter() {
            assert_eq!(verify_share(&share, &keygen_commitment), Ok(()));
        }

        assert_eq!(reconstruct_secret(shares).unwrap(), secret.0)
    }
}
