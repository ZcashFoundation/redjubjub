//! An implementation of FROST (Flexible Round-Optimized Schnorr Threshold)
//! signatures.
//!
//! > **WARNING**: This implementation is unstable and subject to
//! > revision. It is not covered by the crate's semver guarantees and should not
//! > be deployed without consultation from the FROST authors!
//!
//! This implementation currently only supports key generation using a central
//! dealer. In the future, we will add support for key generation via a DKG,
//! as specified in the FROST paper.
//! Internally, keygen_with_dealer generates keys using Verifiable Secret
//! Sharing,  where shares are generated using Shamir Secret Sharing.

// TODO: all public structs/data that includes points must use/wrap
use rand_core::{CryptoRng, RngCore};
use std::convert::TryFrom;

use crate::private::Sealed;
use crate::{Scalar, SpendAuth};

#[derive(Copy, Clone)]
/// Secret is comprised of secret scalar.
pub struct Secret(Scalar);

// TODO: impl From<Scalar> for Secret;

#[derive(Copy, Clone)]
/// Public is comprised of a public group element
pub struct Public(jubjub::ExtendedPoint);

// TODO: impl From<jubjub::ExtendedPoint> for Public;

#[derive(Copy, Clone)]
/// GroupPublic represents the signing group's public key.
pub struct GroupPublic(jubjub::ExtendedPoint);

// TODO: impl From<jubjub::ExtendedPoint> for GroupPublic;

/// A share generated by Shamir's secret sharing.
#[derive(Clone)]
pub struct Share {
    pub(crate) receiver_index: u32,
    pub(crate) value: Secret,
    pub(crate) commitment: ShareCommitment,
}

/// Commitment is a Jubjub point that is a commitment to one coefficient of a
/// secret polynomial.
#[derive(Clone)]
struct Commitment(jubjub::ExtendedPoint);

/// ShareCommitment contains the commitments to the coefficients (which
/// themselves are scalars) for a secret polynomial f, used to generate each
/// participants key shares.
#[derive(Clone)]
pub struct ShareCommitment(Vec<Commitment>);

/// SharePackage is secret and public key material generated by a dealer
/// performing keygen_with_dealer. To derive a FROST keypair, the receiver of
/// the SharePackage *must* call .into(), which under the hood also performs
/// validation.
pub struct SharePackage {
    pub(crate) index: u32,
    pub(crate) share: Share,
    pub(crate) public: Public,
    pub(crate) group_public: GroupPublic,
}

impl TryFrom<SharePackage> for KeyPackage {
    type Error = &'static str;

    fn try_from(sharepackage: SharePackage) -> Result<Self, &'static str> {
        // first, ensure that the share itself is valid
        verify_share(&sharepackage.share)?;

        Ok(KeyPackage {
            index: sharepackage.index,
            secret_share: sharepackage.share.value,
            public: sharepackage.public,
            group_public: sharepackage.group_public,
        })
    }
}

/// KeyPackage is a FROST keypair. This keypair can be generated either by a
/// trusted dealer or using a DKG.
pub struct KeyPackage {
    pub(crate) index: u32,
    pub(crate) secret_share: Secret,
    pub(crate) public: Public,
    pub(crate) group_public: GroupPublic,
}

/// keygen with dealer allows all participants' keys to be generated using a
/// central, trusted dealer. This action is essentially Verifiable Secret
/// Sharing, which itself uses Shamir secret sharing, from which each share
/// becomes a participant's secret key.
/// The output from this function is a set of shares along with one single
/// commitment.
pub fn keygen_with_dealer<R: RngCore + CryptoRng>(
    num_signers: u32,
    threshold: u32,
    mut rng: R,
) -> Result<Vec<SharePackage>, &'static str> {
    let mut bytes = [0; 64];
    rng.fill_bytes(&mut bytes);

    let secret = Secret(Scalar::from_bytes_wide(&bytes));
    let group_public = SpendAuth::basepoint() * secret.0;

    let shares = generate_shares(secret, num_signers, threshold, rng)?;
    let mut sharepackages: Vec<SharePackage> = Vec::with_capacity(num_signers as usize);
    for share in shares {
        sharepackages.push(SharePackage {
            index: share.receiver_index,
            share: share.clone(),
            public: Public(SpendAuth::basepoint() * share.value.0),
            group_public: GroupPublic(group_public),
        });
    }

    Ok(sharepackages)
}

/// verify_shares verifies that a share is consistent with a commitment,
/// ensuring that this participant's share is consistent with all other signing
/// participants. Note that participants *must* ensure that they have the same
/// view as all other participants of the commitment!
fn verify_share(share: &Share) -> Result<(), &'static str> {
    let f_result = SpendAuth::basepoint() * share.value.0;

    let x = Scalar::from(share.receiver_index as u64);

    let (_, result) = share.commitment.0.iter().fold(
        (Scalar::one(), jubjub::ExtendedPoint::identity()),
        |(x_to_the_i, sum_so_far), comm_i| (x_to_the_i * x, sum_so_far + comm_i.0 * x_to_the_i),
    );

    if !(f_result == result) {
        return Err("Share is invalid.");
    }

    Ok(())
}

/// generate_shares creates secret shares for a given secret. This function
/// accepts a secret to generate shares from. While in FROST this secret should
/// always be generated randomly, we allow this secret to be specified for this
/// internal function for testability
///
/// Internally, generate_shares performs Verifiable Secret Sharing, which
/// generates shares via Shamir Secret Sharing, and then generates public
/// commitments to those shares.
/// More specifically, generate_shares performs:
/// - Randomly sampling of coefficents [a, b, c], this represents a secret
/// polynomial f
/// - For each participant i, their secret share is f(i)
/// - The commitment to the secret polynomial f is [g^a, g^b, g^c]
fn generate_shares<R: RngCore + CryptoRng>(
    secret: Secret,
    numshares: u32,
    threshold: u32,
    mut rng: R,
) -> Result<Vec<Share>, &'static str> {
    if threshold < 1 {
        return Err("Threshold cannot be 0");
    }
    if numshares < 1 {
        return Err("Number of shares cannot be 0");
    }
    if threshold > numshares {
        return Err("Threshold cannot exceed numshares");
    }

    let numcoeffs = threshold - 1;

    let mut coefficients: Vec<Scalar> = Vec::with_capacity(threshold as usize);

    let mut shares: Vec<Share> = Vec::with_capacity(numshares as usize);

    let mut commitment: ShareCommitment = ShareCommitment(Vec::with_capacity(threshold as usize));

    for _ in 0..numcoeffs {
        let mut bytes = [0; 64];
        rng.fill_bytes(&mut bytes);
        coefficients.push(Scalar::from_bytes_wide(&bytes));
    }

    commitment
        .0
        .push(Commitment(SpendAuth::basepoint() * secret.0));

    for c in &coefficients {
        commitment.0.push(Commitment(SpendAuth::basepoint() * c));
    }

    for index in 1..numshares + 1 {
        // Evaluate the polynomial with `secret` as the constant term
        // and `coeffs` as the other coefficients at the point x=share_index
        // using Horner's method
        let scalar_index = Scalar::from(index as u64);
        let mut value = Scalar::zero();
        for i in (0..numcoeffs).rev() {
            value += &coefficients[i as usize];
            value *= scalar_index;
        }
        value = value + secret.0;
        shares.push(Share {
            receiver_index: index,
            value: Secret(value),
            commitment: commitment.clone(),
        });
    }

    Ok(shares)
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::{self, rngs::ThreadRng};

    fn reconstruct_secret(shares: Vec<Share>) -> Result<Scalar, &'static str> {
        let numshares = shares.len();

        if numshares < 1 {
            return Err("No shares provided");
        }

        let mut lagrange_coeffs: Vec<Scalar> = Vec::with_capacity(numshares as usize);

        for i in 0..numshares {
            let mut num = Scalar::one();
            let mut den = Scalar::one();
            for j in 0..numshares {
                if j == i {
                    continue;
                }
                num *= Scalar::from(shares[j].receiver_index as u64);
                den *= Scalar::from(shares[j].receiver_index as u64)
                    - Scalar::from(shares[i].receiver_index as u64);
            }
            if den == Scalar::zero() {
                return Err("Duplicate shares provided");
            }
            lagrange_coeffs.push(num * den.invert().unwrap());
        }

        let mut secret = Scalar::zero();

        for i in 0..numshares {
            secret += lagrange_coeffs[i] * shares[i].value.0;
        }

        Ok(secret)
    }

    /// This is testing that Shamir's secret sharing to compute and arbitrary
    /// value is working.
    #[test]
    fn check_share_generation() {
        let mut rng: ThreadRng = rand::thread_rng();

        let mut bytes = [0; 64];
        rng.fill_bytes(&mut bytes);
        let secret = Secret(Scalar::from_bytes_wide(&bytes));

        let _ = SpendAuth::basepoint() * secret.0;

        let shares = generate_shares(secret, 5, 3, rng).unwrap();

        for share in shares.iter() {
            assert_eq!(verify_share(&share), Ok(()));
        }

        assert_eq!(reconstruct_secret(shares).unwrap(), secret.0)
    }
}
